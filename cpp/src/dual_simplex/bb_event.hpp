/* clang-format off */
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
/* clang-format on */

#pragma once

#include <algorithm>
#include <cstdint>
#include <tuple>
#include <variant>
#include <vector>

namespace cuopt::linear_programming::dual_simplex {

// Event types generated by B&B workers during deterministic execution
enum class bb_event_type_t : int8_t {
  NODE_BRANCHED      = 0,
  NODE_FATHOMED      = 1,
  NODE_INTEGER       = 2,
  NODE_PAUSED        = 3,
  NODE_INFEASIBLE    = 4,
  NODE_NUMERICAL     = 5,
  HEURISTIC_SOLUTION = 6
};

template <typename i_t, typename f_t>
struct branched_payload_t {
  i_t down_child_id;
  i_t up_child_id;
  f_t node_lower_bound;
  i_t branch_var;
  f_t branch_value;
};

template <typename f_t>
struct integer_solution_payload_t {
  f_t objective_value;
};

template <typename f_t>
struct fathomed_payload_t {
  f_t lower_bound;
};

template <typename f_t>
struct paused_payload_t {
  f_t accumulated_wut;
};

template <typename f_t>
struct heuristic_solution_payload_t {
  f_t objective_value;
  size_t solution_index;
};

template <typename i_t, typename f_t>
struct bb_event_t {
  bb_event_type_t type;
  double wut;
  int worker_id;
  i_t node_id;
  int event_sequence;

  union {
    branched_payload_t<i_t, f_t> branched;
    integer_solution_payload_t<f_t> integer_solution;
    fathomed_payload_t<f_t> fathomed;
    paused_payload_t<f_t> paused;
    heuristic_solution_payload_t<f_t> heuristic;
  } payload;

  bb_event_t()
    : type(bb_event_type_t::NODE_FATHOMED), wut(0.0), worker_id(0), node_id(0), event_sequence(0)
  {
    payload.fathomed = {0.0};
  }

  bool operator<(const bb_event_t& other) const
  {
    return std::tie(wut, worker_id, event_sequence) <
           std::tie(other.wut, other.worker_id, other.event_sequence);
  }

  static bb_event_t make_branched(double work_unit_ts,
                                  int worker,
                                  i_t node,
                                  int seq,
                                  i_t down_id,
                                  i_t up_id,
                                  f_t lower_bound,
                                  i_t branch_var,
                                  f_t branch_val)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_BRANCHED;
    e.wut              = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.event_sequence   = seq;
    e.payload.branched = {down_id, up_id, lower_bound, branch_var, branch_val};
    return e;
  }

  static bb_event_t make_integer_solution(
    double work_unit_ts, int worker, i_t node, int seq, f_t objective)
  {
    bb_event_t e;
    e.type                     = bb_event_type_t::NODE_INTEGER;
    e.wut                      = work_unit_ts;
    e.worker_id                = worker;
    e.node_id                  = node;
    e.event_sequence           = seq;
    e.payload.integer_solution = {objective};
    return e;
  }

  static bb_event_t make_fathomed(
    double work_unit_ts, int worker, i_t node, int seq, f_t lower_bound)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_FATHOMED;
    e.wut              = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.event_sequence   = seq;
    e.payload.fathomed = {lower_bound};
    return e;
  }

  static bb_event_t make_infeasible(double work_unit_ts, int worker, i_t node, int seq)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_INFEASIBLE;
    e.wut              = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.event_sequence   = seq;
    e.payload.fathomed = {std::numeric_limits<f_t>::infinity()};
    return e;
  }

  static bb_event_t make_paused(double work_unit_ts, int worker, i_t node, int seq, f_t accumulated)
  {
    bb_event_t e;
    e.type           = bb_event_type_t::NODE_PAUSED;
    e.wut            = work_unit_ts;
    e.worker_id      = worker;
    e.node_id        = node;
    e.event_sequence = seq;
    e.payload.paused = {accumulated};
    return e;
  }

  static bb_event_t make_numerical(double work_unit_ts, int worker, i_t node, int seq)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_NUMERICAL;
    e.wut              = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.event_sequence   = seq;
    e.payload.fathomed = {std::numeric_limits<f_t>::infinity()};
    return e;
  }

  static bb_event_t make_heuristic_solution(
    double work_unit_ts, int worker, int seq, f_t objective, size_t sol_idx)
  {
    bb_event_t e;
    e.type              = bb_event_type_t::HEURISTIC_SOLUTION;
    e.wut               = work_unit_ts;
    e.worker_id         = worker;
    e.node_id           = -1;
    e.event_sequence    = seq;
    e.payload.heuristic = {objective, sol_idx};
    return e;
  }
};

template <typename i_t, typename f_t>
struct bb_event_batch_t {
  std::vector<bb_event_t<i_t, f_t>> events;
  double horizon_start;
  double horizon_end;

  void clear()
  {
    events.clear();
    horizon_start = 0.0;
    horizon_end   = 0.0;
  }

  void add(bb_event_t<i_t, f_t> event) { events.push_back(std::move(event)); }

  // Sort events for deterministic replay
  void sort_for_replay() { std::sort(events.begin(), events.end()); }

  size_t size() const { return events.size(); }
  bool empty() const { return events.empty(); }
};

}  // namespace cuopt::linear_programming::dual_simplex
